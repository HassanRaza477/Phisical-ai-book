"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[3437],{4519:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapters/part1/chapter3","title":"Chapter 3: Simulating Humanoids in Gazebo","description":"In the previous chapter, we learned the language of ROS 2. Now, we\'ll give our ROS 2 system a body and a world to live in. Welcome to Gazebo, the workhorse of the ROS ecosystem and your first step into robotics simulation.","source":"@site/docs/chapters/part1/chapter3.md","sourceDirName":"chapters/part1","slug":"/chapters/part1/chapter3","permalink":"/Phisical-ai-book/docs/chapters/part1/chapter3","draft":false,"unlisted":false,"editUrl":"https://github.com/HassanRaza477/Phisical-ai-book.git/docs/chapters/part1/chapter3.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Fundamentals of ROS 2","permalink":"/Phisical-ai-book/docs/chapters/part1/chapter2"},"next":{"title":"Chapter 4: Advanced Visual Simulation with Unity","permalink":"/Phisical-ai-book/docs/chapters/part1/chapter4"}}');var r=o(4848),i=o(8453);const a={},s="Chapter 3: Simulating Humanoids in Gazebo",l={},c=[{value:"URDF: Describing Your Robot&#39;s Body",id:"urdf-describing-your-robots-body",level:2},{value:"<code>ros2_control</code>: The Universal Controller",id:"ros2_control-the-universal-controller",level:2},{value:"Spawning and Controlling the Humanoid",id:"spawning-and-controlling-the-humanoid",level:2},{value:"Reading Sensor Data",id:"reading-sensor-data",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-3-simulating-humanoids-in-gazebo",children:"Chapter 3: Simulating Humanoids in Gazebo"})}),"\n",(0,r.jsx)(n.p,{children:"In the previous chapter, we learned the language of ROS 2. Now, we'll give our ROS 2 system a body and a world to live in. Welcome to Gazebo, the workhorse of the ROS ecosystem and your first step into robotics simulation."}),"\n",(0,r.jsx)(n.p,{children:"Gazebo is a 3D rigid-body dynamics simulator. In simpler terms, it's a virtual world with a physics engine where we can build, test, and interact with our robots as if they were real. It's not as visually fancy as a modern video game, but it is deeply integrated with ROS and provides a robust platform for testing control algorithms and sensor integrations."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"(Screenshot: A picture of the Gazebo interface with a simple robot in an empty world.)"})}),"\n",(0,r.jsx)(n.h2,{id:"urdf-describing-your-robots-body",children:"URDF: Describing Your Robot's Body"}),"\n",(0,r.jsxs)(n.p,{children:["To put a robot in Gazebo, we first need to describe it. The standard format for this in ROS is the ",(0,r.jsx)(n.strong,{children:"Unified Robot Description Format (URDF)"}),". An URDF file is an XML file that describes the robot's physical structure as a tree of ",(0,r.jsx)(n.strong,{children:"links"})," (the rigid parts) and ",(0,r.jsx)(n.strong,{children:"joints"})," (the connections between links)."]}),"\n",(0,r.jsx)(n.p,{children:'Let\'s create a very simple "humanoid": a torso with a single arm that can rotate.'}),"\n",(0,r.jsxs)(n.p,{children:["Create a new package for our robot description:\n",(0,r.jsx)(n.code,{children:"ros2 pkg create --build-type ament_cmake simple_humanoid_description"})]}),"\n",(0,r.jsxs)(n.p,{children:["Inside ",(0,r.jsx)(n.code,{children:"simple_humanoid_description"}),", create a ",(0,r.jsx)(n.code,{children:"urdf"})," directory and a file named ",(0,r.jsx)(n.code,{children:"single_arm_humanoid.urdf"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- simple_humanoid_description/urdf/single_arm_humanoid.urdf --\x3e\n<robot name="single_arm_humanoid">\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.4 0.2 0.8"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.4 0.2 0.8"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n  </link>\n\n  <link name="arm">\n    <visual>\n      <geometry>\n        <cylinder length="0.5" radius="0.05"/>\n      </geometry>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.5" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n  </link>\n\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="arm"/>\n    <origin xyz="0 0.2 0.3" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit effort="100" lower="-1.57" upper="1.57" velocity="1.0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note on SDF"}),": You may also encounter the ",(0,r.jsx)(n.strong,{children:"Simulation Description Format (SDF)"}),". SDF is Gazebo's native format and is more powerful than URDF (it can describe entire worlds, not just robots). ROS tools, however, primarily work with URDF. Often, the URDF is converted to SDF internally by Gazebo."]}),"\n",(0,r.jsxs)(n.h2,{id:"ros2_control-the-universal-controller",children:[(0,r.jsx)(n.code,{children:"ros2_control"}),": The Universal Controller"]}),"\n",(0,r.jsxs)(n.p,{children:["How do we command the ",(0,r.jsx)(n.code,{children:"shoulder_joint"})," we just defined? We use ",(0,r.jsx)(n.code,{children:"ros2_control"}),". This is a critical framework that provides a hardware abstraction layer for your robot. You write your high-level control code once, and the ",(0,r.jsx)(n.code,{children:"ros2_control"})," framework handles the specifics of whether it's talking to a real motor or a simulated joint."]}),"\n",(0,r.jsxs)(n.p,{children:["To use it with Gazebo, we need to add a special Gazebo plugin to our URDF. This plugin tells Gazebo that our robot's joints will be managed by ",(0,r.jsx)(n.code,{children:"ros2_control"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"spawning-and-controlling-the-humanoid",children:"Spawning and Controlling the Humanoid"}),"\n",(0,r.jsx)(n.p,{children:"Putting it all together involves a few moving parts:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"A Launch File"}),": This will start Gazebo, load our URDF, and spawn the robot model into the simulation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controller Configuration (YAML)"}),": A YAML file that defines which controllers to use for which joints."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spawning the Controller"}),": A node that loads the controllers defined in the YAML file and connects them to the robot's joints."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Here is an example of what a controller configuration file looks like. Let's call it ",(0,r.jsx)(n.code,{children:"simple_controllers.yaml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"controller_manager:\n  ros__parameters:\n    update_rate: 100\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - shoulder_joint\n    command_interfaces:\n      - position\n    state_interfaces:\n      - position\n      - velocity\n"})}),"\n",(0,r.jsx)(n.p,{children:"This configuration sets up two standard controllers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"joint_state_broadcaster"}),": This reads the state of all joints (position, velocity) and publishes them on the ",(0,r.jsx)(n.code,{children:"/joint_states"})," topic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"joint_trajectory_controller"}),": This provides a ROS 2 Action interface to command one or more joints to follow a trajectory."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Now, we can write a launch file that starts Gazebo, loads our robot, and starts these controllers."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["(Screenshot: A picture of ",(0,r.jsx)(n.code,{children:"rviz2"})," showing the humanoid model. A separate window shows a terminal with a command to send a joint goal.)"]})}),"\n",(0,r.jsx)(n.p,{children:"With everything running, you can now send a command to the arm!"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Send a goal to the joint trajectory controller to move the shoulder_joint to 1.0 radian\nros2 action send_goal /joint_trajectory_controller trajectory_msgs/action/FollowJointTrajectory '{trajectory: {joint_names: [\"shoulder_joint\"], points: [{positions: [1.0], time_from_start: {sec: 2}}]}}'\n"})}),"\n",(0,r.jsx)(n.p,{children:"You should see the arm of your simple humanoid move in Gazebo!"}),"\n",(0,r.jsx)(n.h2,{id:"reading-sensor-data",children:"Reading Sensor Data"}),"\n",(0,r.jsx)(n.p,{children:"Let's add an IMU (Inertial Measurement Unit) sensor to our robot's torso to measure its orientation. We add this to the URDF using a special Gazebo sensor plugin."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add this inside the <robot> tag in your URDF --\x3e\n<gazebo reference="torso">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <plugin name="gazebo_ros_imu_sensor" filename="libgazebo_ros_imu_sensor.so">\n      <ros>\n        <namespace>/demo</namespace>\n        <remapping>~/out:=imu</remapping>\n      </ros>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(n.p,{children:'After relaunching the simulation, you can now "listen" to the IMU data on a ROS 2 topic:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /demo/imu\n"})}),"\n",(0,r.jsx)(n.p,{children:'This chapter was a major step. You have learned how to describe a robot, place it in a simulated world, and control its joints using standard ROS 2 interfaces. You\'ve bridged the gap between pure software and a "physical" (albeit simulated) entity. In the next chapters, we will explore more advanced simulators that allow for even greater realism.'})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>s});var t=o(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);